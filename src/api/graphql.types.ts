/* eslint-disable @typescript-eslint/ban-types */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  JSON: Object;
};

/** Autogenerated return type of ChangeCurrentUserPassword. */
export type ChangeCurrentUserPasswordPayload = {
  __typename?: 'ChangeCurrentUserPasswordPayload';
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
};

/** Autogenerated return type of CreateEmail. */
export type CreateEmailPayload = {
  __typename?: 'CreateEmailPayload';
  email: Maybe<Email>;
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
};

/** Autogenerated return type of CreatePhone. */
export type CreatePhonePayload = {
  __typename?: 'CreatePhonePayload';
  errors: Maybe<Scalars['JSON']>;
  phone: Maybe<Phone>;
  status: Maybe<Status>;
};

export type Email = {
  __typename?: 'Email';
  email: Scalars['String'];
  id: Scalars['ID'];
  isPrimary: Scalars['Boolean'];
  verificationStatus: VerificationStatusEnum;
};

export type Errors = {
  __typename?: 'Errors';
  oneTimePassword: Maybe<Array<Scalars['String']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  changeCurrentUserPassword: Maybe<ChangeCurrentUserPasswordPayload>;
  createEmail: Maybe<CreateEmailPayload>;
  createPhone: Maybe<CreatePhonePayload>;
  sendOneTimePassword: Maybe<SendOneTimePasswordPayload>;
  signinUser: Maybe<SigninUserPayload>;
  signupUser: Maybe<SignupUserPayload>;
  updateCurrentUserInfo: Maybe<UpdateCurrentUserInfoMutationPayload>;
  verifyOneTimePassword: Maybe<VerifyOneTimePasswordPayload>;
};

export type MutationChangeCurrentUserPasswordArgs = {
  newPassword: Scalars['String'];
  newPasswordConfirmation: Scalars['String'];
  oldPassword: Scalars['String'];
};

export type MutationCreateEmailArgs = {
  email: Scalars['String'];
};

export type MutationCreatePhoneArgs = {
  number: Scalars['String'];
};

export type MutationSendOneTimePasswordArgs = {
  code: Scalars['String'];
  number: Scalars['String'];
};

export type MutationSigninUserArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationSignupUserArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationUpdateCurrentUserInfoArgs = {
  firstName: Scalars['String'];
  lastName?: InputMaybe<Scalars['String']>;
};

export type MutationVerifyOneTimePasswordArgs = {
  code: Scalars['String'];
  number: Scalars['String'];
  oneTimePassword: Scalars['String'];
};

export type Phone = {
  __typename?: 'Phone';
  code: Scalars['String'];
  id: Scalars['ID'];
  isPrimary: Scalars['Boolean'];
  number: Scalars['String'];
  verificationStatus: VerificationStatusEnum;
};

export type Query = {
  __typename?: 'Query';
  user: Maybe<User>;
};

export type QueryUserArgs = {
  userId: Scalars['ID'];
};

/** Autogenerated return type of SendOneTimePassword. */
export type SendOneTimePasswordPayload = {
  __typename?: 'SendOneTimePasswordPayload';
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
};

/** Autogenerated return type of SigninUser. */
export type SigninUserPayload = {
  __typename?: 'SigninUserPayload';
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
  token: Maybe<Scalars['String']>;
  user: Maybe<User>;
};

/** Autogenerated return type of SignupUser. */
export type SignupUserPayload = {
  __typename?: 'SignupUserPayload';
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
  token: Maybe<Scalars['String']>;
  user: Maybe<User>;
};

export enum Status {
  Failure = 'failure',
  Success = 'success',
}

/** Autogenerated return type of UpdateCurrentUserInfoMutation. */
export type UpdateCurrentUserInfoMutationPayload = {
  __typename?: 'UpdateCurrentUserInfoMutationPayload';
  errors: Maybe<Scalars['JSON']>;
  status: Maybe<Status>;
  user: User;
};

export type User = {
  __typename?: 'User';
  emails: Array<Email>;
  firstName: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  kind: UserKind;
  languageCode: Scalars['String'];
  lastName: Maybe<Scalars['String']>;
  phones: Array<Phone>;
};

export enum UserKind {
  Anonymous = 'anonymous',
  Real = 'real',
}

export enum VerificationStatusEnum {
  Failed = 'failed',
  InProgress = 'in_progress',
  Succeeded = 'succeeded',
}

/** Autogenerated return type of VerifyOneTimePassword. */
export type VerifyOneTimePasswordPayload = {
  __typename?: 'VerifyOneTimePasswordPayload';
  errors: Errors;
  status: Maybe<Status>;
  token: Scalars['String'];
  user: User;
};

export type SendOneTimePasswordMutationVariables = Exact<{
  code: Scalars['String'];
  number: Scalars['String'];
}>;

export type SendOneTimePasswordMutation = {
  __typename?: 'Mutation';
  sendOneTimePassword: {
    __typename?: 'SendOneTimePasswordPayload';
    status: Status | null;
    errors: Object | null;
  } | null;
};

export type VerifyOneTimePasswordMutationVariables = Exact<{
  oneTimePassword: Scalars['String'];
  code: Scalars['String'];
  number: Scalars['String'];
}>;

export type VerifyOneTimePasswordMutation = {
  __typename?: 'Mutation';
  verifyOneTimePassword: {
    __typename?: 'VerifyOneTimePasswordPayload';
    status: Status | null;
    token: string;
    user: {
      __typename?: 'User';
      id: string;
      firstName: string | null;
      lastName: string | null;
      languageCode: string;
      kind: UserKind;
      phones: Array<{
        __typename?: 'Phone';
        id: string;
        code: string;
        number: string;
        isPrimary: boolean;
        verificationStatus: VerificationStatusEnum;
      }>;
      emails: Array<{
        __typename?: 'Email';
        id: string;
        email: string;
        isPrimary: boolean;
        verificationStatus: VerificationStatusEnum;
      }>;
    };
    errors: { __typename?: 'Errors'; oneTimePassword: Array<string> | null };
  } | null;
};

export type EmailFieldsFragment = {
  __typename?: 'Email';
  id: string;
  email: string;
  isPrimary: boolean;
  verificationStatus: VerificationStatusEnum;
};

export type PhoneFieldsFragment = {
  __typename?: 'Phone';
  id: string;
  code: string;
  number: string;
  isPrimary: boolean;
  verificationStatus: VerificationStatusEnum;
};

export type UserFieldsFragment = {
  __typename?: 'User';
  id: string;
  firstName: string | null;
  lastName: string | null;
  languageCode: string;
  kind: UserKind;
  phones: Array<{
    __typename?: 'Phone';
    id: string;
    code: string;
    number: string;
    isPrimary: boolean;
    verificationStatus: VerificationStatusEnum;
  }>;
  emails: Array<{
    __typename?: 'Email';
    id: string;
    email: string;
    isPrimary: boolean;
    verificationStatus: VerificationStatusEnum;
  }>;
};

export type UpdateCurrentUserInfoMutationVariables = Exact<{
  firstName: Scalars['String'];
  lastName?: InputMaybe<Scalars['String']>;
}>;

export type UpdateCurrentUserInfoMutation = {
  __typename?: 'Mutation';
  updateCurrentUserInfo: {
    __typename?: 'UpdateCurrentUserInfoMutationPayload';
    status: Status | null;
    errors: Object | null;
    user: {
      __typename?: 'User';
      id: string;
      firstName: string | null;
      lastName: string | null;
      languageCode: string;
      kind: UserKind;
      phones: Array<{
        __typename?: 'Phone';
        id: string;
        code: string;
        number: string;
        isPrimary: boolean;
        verificationStatus: VerificationStatusEnum;
      }>;
      emails: Array<{
        __typename?: 'Email';
        id: string;
        email: string;
        isPrimary: boolean;
        verificationStatus: VerificationStatusEnum;
      }>;
    };
  } | null;
};

export type GetUserQueryVariables = Exact<{
  userId: Scalars['ID'];
}>;

export type GetUserQuery = {
  __typename?: 'Query';
  user: {
    __typename?: 'User';
    id: string;
    firstName: string | null;
    lastName: string | null;
    languageCode: string;
    kind: UserKind;
    phones: Array<{
      __typename?: 'Phone';
      id: string;
      code: string;
      number: string;
      isPrimary: boolean;
      verificationStatus: VerificationStatusEnum;
    }>;
    emails: Array<{
      __typename?: 'Email';
      id: string;
      email: string;
      isPrimary: boolean;
      verificationStatus: VerificationStatusEnum;
    }>;
  } | null;
};

export const PhoneFieldsFragmentDoc = gql`
  fragment PhoneFields on Phone {
    id
    code
    number
    isPrimary
    verificationStatus
  }
`;
export const EmailFieldsFragmentDoc = gql`
  fragment EmailFields on Email {
    id
    email
    isPrimary
    verificationStatus
  }
`;
export const UserFieldsFragmentDoc = gql`
  fragment UserFields on User {
    id
    firstName
    lastName
    languageCode
    kind
    phones {
      ...PhoneFields
    }
    emails {
      ...EmailFields
    }
  }
  ${PhoneFieldsFragmentDoc}
  ${EmailFieldsFragmentDoc}
`;
export const SendOneTimePasswordDocument = gql`
  mutation SendOneTimePassword($code: String!, $number: String!) {
    sendOneTimePassword(code: $code, number: $number) {
      status
      errors
    }
  }
`;
export type SendOneTimePasswordMutationFn = Apollo.MutationFunction<
  SendOneTimePasswordMutation,
  SendOneTimePasswordMutationVariables
>;

/**
 * __useSendOneTimePasswordMutation__
 *
 * To run a mutation, you first call `useSendOneTimePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendOneTimePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendOneTimePasswordMutation, { data, loading, error }] = useSendOneTimePasswordMutation({
 *   variables: {
 *      code: // value for 'code'
 *      number: // value for 'number'
 *   },
 * });
 */
export function useSendOneTimePasswordMutation(
  baseOptions?: Apollo.MutationHookOptions<SendOneTimePasswordMutation, SendOneTimePasswordMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<SendOneTimePasswordMutation, SendOneTimePasswordMutationVariables>(
    SendOneTimePasswordDocument,
    options
  );
}
export type SendOneTimePasswordMutationHookResult = ReturnType<typeof useSendOneTimePasswordMutation>;
export type SendOneTimePasswordMutationResult = Apollo.MutationResult<SendOneTimePasswordMutation>;
export type SendOneTimePasswordMutationOptions = Apollo.BaseMutationOptions<
  SendOneTimePasswordMutation,
  SendOneTimePasswordMutationVariables
>;
export const VerifyOneTimePasswordDocument = gql`
  mutation VerifyOneTimePassword($oneTimePassword: String!, $code: String!, $number: String!) {
    verifyOneTimePassword(oneTimePassword: $oneTimePassword, code: $code, number: $number) {
      user {
        ...UserFields
      }
      status
      token
      errors {
        oneTimePassword
      }
    }
  }
  ${UserFieldsFragmentDoc}
`;
export type VerifyOneTimePasswordMutationFn = Apollo.MutationFunction<
  VerifyOneTimePasswordMutation,
  VerifyOneTimePasswordMutationVariables
>;

/**
 * __useVerifyOneTimePasswordMutation__
 *
 * To run a mutation, you first call `useVerifyOneTimePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyOneTimePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyOneTimePasswordMutation, { data, loading, error }] = useVerifyOneTimePasswordMutation({
 *   variables: {
 *      oneTimePassword: // value for 'oneTimePassword'
 *      code: // value for 'code'
 *      number: // value for 'number'
 *   },
 * });
 */
export function useVerifyOneTimePasswordMutation(
  baseOptions?: Apollo.MutationHookOptions<VerifyOneTimePasswordMutation, VerifyOneTimePasswordMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<VerifyOneTimePasswordMutation, VerifyOneTimePasswordMutationVariables>(
    VerifyOneTimePasswordDocument,
    options
  );
}
export type VerifyOneTimePasswordMutationHookResult = ReturnType<typeof useVerifyOneTimePasswordMutation>;
export type VerifyOneTimePasswordMutationResult = Apollo.MutationResult<VerifyOneTimePasswordMutation>;
export type VerifyOneTimePasswordMutationOptions = Apollo.BaseMutationOptions<
  VerifyOneTimePasswordMutation,
  VerifyOneTimePasswordMutationVariables
>;
export const UpdateCurrentUserInfoDocument = gql`
  mutation UpdateCurrentUserInfo($firstName: String!, $lastName: String) {
    updateCurrentUserInfo(firstName: $firstName, lastName: $lastName) {
      user {
        ...UserFields
      }
      status
      errors
    }
  }
  ${UserFieldsFragmentDoc}
`;
export type UpdateCurrentUserInfoMutationFn = Apollo.MutationFunction<
  UpdateCurrentUserInfoMutation,
  UpdateCurrentUserInfoMutationVariables
>;

/**
 * __useUpdateCurrentUserInfoMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentUserInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentUserInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentUserInfoMutation, { data, loading, error }] = useUpdateCurrentUserInfoMutation({
 *   variables: {
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *   },
 * });
 */
export function useUpdateCurrentUserInfoMutation(
  baseOptions?: Apollo.MutationHookOptions<UpdateCurrentUserInfoMutation, UpdateCurrentUserInfoMutationVariables>
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<UpdateCurrentUserInfoMutation, UpdateCurrentUserInfoMutationVariables>(
    UpdateCurrentUserInfoDocument,
    options
  );
}
export type UpdateCurrentUserInfoMutationHookResult = ReturnType<typeof useUpdateCurrentUserInfoMutation>;
export type UpdateCurrentUserInfoMutationResult = Apollo.MutationResult<UpdateCurrentUserInfoMutation>;
export type UpdateCurrentUserInfoMutationOptions = Apollo.BaseMutationOptions<
  UpdateCurrentUserInfoMutation,
  UpdateCurrentUserInfoMutationVariables
>;
export const GetUserDocument = gql`
  query GetUser($userId: ID!) {
    user(userId: $userId) {
      ...UserFields
    }
  }
  ${UserFieldsFragmentDoc}
`;

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetUserQuery(baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, options);
}
export function useGetUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(GetUserDocument, options);
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>;
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>;
export type GetUserQueryResult = Apollo.QueryResult<GetUserQuery, GetUserQueryVariables>;
